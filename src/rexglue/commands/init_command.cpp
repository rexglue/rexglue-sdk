/**
 * @file        rexglue/commands/init_command.cpp
 * @brief       Project initialization command implementation
 *
 * @copyright   Copyright (c) 2026 Tom Clay <tomc@tctechstuff.com>
 *              All rights reserved.
 *
 * @license     BSD 3-Clause License
 *              See LICENSE file in the project root for full license text.
 */

#include "init_command.h"
#include <rex/logging.h>
#include <rex/result.h>

#include <filesystem>
#include <fstream>
#include <algorithm>
#include <cctype>
#include <vector>

namespace fs = std::filesystem;

namespace rexglue::cli {

using rex::Error;
using rex::ErrorCategory;
using rex::Err;
using rex::Ok;

// TODO(tomc): cleanup this shtsuff. we should have templates for file generation. idk theres prob a lib for that
namespace {

struct AppNameParts {
    std::string snake_case;   // files, cmake target, etc.
    std::string pascal_case;  // class/object names
    std::string upper_case;   // cmake variables
};

bool validate_app_name(const std::string& input, std::string& error) {
    if (input.empty()) {
        error = "App name must not be empty";
        return false;
    }
    if (!std::isalpha(static_cast<unsigned char>(input[0]))) {
        error = "App name must start with a letter";
        return false;
    }
    for (char c : input) {
        if (!std::isalnum(static_cast<unsigned char>(c)) && c != '_' && c != '-' && c != ' ') {
            error = "App name contains invalid character '" + std::string(1, c) +
                    "'. Only alphanumeric, space, underscore, and dash are allowed";
            return false;
        }
    }
    return true;
}

AppNameParts parse_app_name(const std::string& input) {
    // Split on separators (space, underscore, dash), consecutive separators treated as one
    std::vector<std::string> words;
    std::string current;
    for (char c : input) {
        if (c == ' ' || c == '_' || c == '-') {
            if (!current.empty()) {
                words.push_back(current);
                current.clear();
            }
        } else {
            current += static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
        }
    }
    if (!current.empty()) {
        words.push_back(current);
    }

    AppNameParts parts;

    // snake_case: join with underscores, all lowercase
    for (size_t i = 0; i < words.size(); ++i) {
        if (i > 0) parts.snake_case += '_';
        parts.snake_case += words[i];
    }

    // pascal_case: capitalize first letter of each word, concatenate
    for (const auto& w : words) {
        std::string word = w;
        if (!word.empty() && std::isalpha(static_cast<unsigned char>(word[0]))) {
            word[0] = static_cast<char>(std::toupper(static_cast<unsigned char>(word[0])));
        }
        parts.pascal_case += word;
    }

    // upper_case: all uppercase, no separators
    for (const auto& w : words) {
        for (char c : w) {
            parts.upper_case += static_cast<char>(std::toupper(static_cast<unsigned char>(c)));
        }
    }

    return parts;
}

// Generate CMakeLists.txt content
std::string generate_cmakelists(const AppNameParts& names) {
    std::string content;

    content += "# " + names.snake_case + " - ReXGlue Recompiled Project\n";
    content += "# Generated by: rexglue init\n";
    content += "\n";
    content += "cmake_minimum_required(VERSION 3.25)\n";
    content += "project(" + names.snake_case + " LANGUAGES CXX)\n";
    content += "\n";
    content += "set(CMAKE_CXX_STANDARD 23)\n";
    content += "set(CMAKE_CXX_STANDARD_REQUIRED ON)\n";
    content += "\n";
    content += "# Find ReXGlue SDK\n";
    content += "# REXSDK env var takes precedence, otherwise search system paths\n";
    content += "if(DEFINED ENV{REXSDK})\n";
    content += "    list(PREPEND CMAKE_PREFIX_PATH $ENV{REXSDK})\n";
    content += "endif()\n";
    content += "find_package(rexglue REQUIRED)\n";
    content += "if(NOT rexglue_FOUND)\n";
    content += "    message(FATAL_ERROR \"ReXGlue SDK was not found in environment variables or from find_package.\")\n";
    content += "endif()\n";
    content += "\n";
    content += "# User source files\n";
    content += "set(" + names.upper_case + "_SOURCES\n";
    content += "    src/main.cpp\n";
    content += ")\n";
    content += "\n";
    content += "# Platform-specific entry point (provides main/wWinMain)\n";
    content += "if(WIN32)\n";
    content += "    list(APPEND " + names.upper_case + "_SOURCES ${REXGLUE_SHARE_DIR}/windowed_app_main_win.cpp)\n";
    content += "else()\n";
    content += "    list(APPEND " + names.upper_case + "_SOURCES ${REXGLUE_SHARE_DIR}/windowed_app_main_posix.cpp)\n";
    content += "endif()\n";
    content += "\n";
    content += "# Include generated code if codegen has been run\n";
    content += "if(EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/generated/sources.cmake\")\n";
    content += "    include(generated/sources.cmake)\n";
    content += "    list(APPEND " + names.upper_case + "_SOURCES ${GENERATED_SOURCES})\n";
    content += "endif()\n";
    content += "\n";
    content += "if(WIN32)\n";
    content += "    add_executable(" + names.snake_case + " WIN32 ${" + names.upper_case + "_SOURCES})\n";
    content += "else()\n";
    content += "    add_executable(" + names.snake_case + " ${" + names.upper_case + "_SOURCES})\n";
    content += "endif()\n";
    content += "\n";
    content += "target_include_directories(" + names.snake_case + " PRIVATE\n";
    content += "    ${CMAKE_CURRENT_SOURCE_DIR}\n";
    content += "    ${CMAKE_CURRENT_SOURCE_DIR}/generated\n";
    content += ")\n";
    content += "\n";
    content += "target_link_libraries(" + names.snake_case + " PRIVATE\n";
    content += "    rex::core\n";
    content += "    rex::runtime\n";
    content += "    rex::kernel\n";
    content += "    rex::graphics\n";
    content += "    rex::ui\n";
    content += ")\n";
    content += "\n";
    content += "# Platform-specific settings\n";
    content += "if(UNIX AND NOT APPLE)\n";
    content += "    # GTK3 for entry point (windowed_app_main_posix.cpp)\n";
    content += "    find_package(PkgConfig REQUIRED)\n";
    content += "    pkg_check_modules(GTK3 REQUIRED gtk+-3.0)\n";
    content += "    target_include_directories(" + names.snake_case + " PRIVATE ${GTK3_INCLUDE_DIRS})\n";
    content += "    target_link_libraries(" + names.snake_case + " PRIVATE ${GTK3_LIBRARIES})\n";
    content += "\n";
    content += "    # Whole-archive linking for kernel hooks\n";
    content += "    target_link_options(" + names.snake_case + " PRIVATE\n";
    content += "        -Wl,--whole-archive\n";
    content += "        $<TARGET_FILE:rex::kernel>\n";
    content += "        -Wl,--no-whole-archive\n";
    content += "    )\n";
    content += "    # Large executable support\n";
    content += "    target_link_options(" + names.snake_case + " PRIVATE -Wl,--no-relax)\n";
    content += "    target_compile_options(" + names.snake_case + " PRIVATE -mcmodel=large)\n";
    content += "endif()\n";
    content += "\n";
    content += "if(NOT MSVC)\n";
    content += "    target_compile_options(" + names.snake_case + " PRIVATE -msse4.1)\n";
    content += "endif()\n";
    content += "\n";
    content += "# Codegen target - run 'cmake --build . --target " + names.snake_case + "_codegen'\n";
    content += "add_custom_target(" + names.snake_case + "_codegen\n";
    content += "    COMMAND $<TARGET_FILE:rex::rexglue> codegen ${CMAKE_CURRENT_SOURCE_DIR}/" + names.snake_case + "_config.toml\n";
    content += "    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n";
    content += "    COMMENT \"Generating recompiled code for " + names.snake_case + "\"\n";
    content += "    VERBATIM\n";
    content += ")\n";

    return content;
}

// Generate main.cpp content
std::string generate_main_cpp(const AppNameParts& names) {
    std::string class_name = names.pascal_case + "App";
    std::string content;

    content += "// " + names.snake_case + " - ReXGlue Recompiled Project\n";
    content += "// Generated by: rexglue init\n";
    content += "\n";
    content += "#include \"generated/" + names.snake_case + "_config.h\"\n";
    content += "#include \"generated/" + names.snake_case + "_init.h\"\n";
    content += "\n";
    content += "#include <rex/filesystem.h>\n";
    content += "#include <rex/runtime.h>\n";
    content += "#include <rex/logging.h>\n";
    content += "#include <rex/kernel/xthread.h>\n";
    content += "#include <rex/graphics/graphics_system.h>\n";
    content += "#include <rex/ui/window.h>\n";
    content += "#include <rex/ui/window_listener.h>\n";
    content += "#include <rex/ui/windowed_app.h>\n";
    content += "\n";
    content += "#include <filesystem>\n";
    content += "#include <thread>\n";
    content += "\n";
    content += "class " + class_name + " : public rex::ui::WindowedApp, public rex::ui::WindowListener {\n";
    content += "public:\n";
    content += "    static std::unique_ptr<rex::ui::WindowedApp> Create(rex::ui::WindowedAppContext& ctx) {\n";
    content += "        return std::make_unique<" + class_name + ">(ctx);\n";
    content += "    }\n";
    content += "\n";
    content += "    " + class_name + "(rex::ui::WindowedAppContext& ctx)\n";
    content += "        : WindowedApp(ctx, \"" + names.snake_case + "\", \"[game_directory]\") {\n";
    content += "        AddPositionalOption(\"game_directory\");\n";
    content += "    }\n";
    content += "\n";
    content += "    bool OnInitialize() override {\n";
    content += "        auto exe_dir = rex::filesystem::GetExecutableFolder();\n";
    content += "\n";
    content += "        // Game directory: arg or default to exe_dir/assets\n";
    content += "        std::filesystem::path game_dir;\n";
    content += "        if (auto arg = GetArgument(\"game_directory\")) {\n";
    content += "            game_dir = *arg;\n";
    content += "        } else {\n";
    content += "            game_dir = exe_dir / \"assets\";\n";
    content += "        }\n";
    content += "\n";
    content += "        // Initialize logging\n";
    content += "        auto log_file = exe_dir / \"" + names.snake_case + ".log\";\n";
    content += "        rex::InitLogging(log_file.string().c_str(), spdlog::level::debug);\n";
    content += "        REXLOG_INFO(\"" + names.snake_case + " starting\");\n";
    content += "        REXLOG_INFO(\"  Game directory: {}\", game_dir.string());\n";
    content += "\n";
    content += "        // Create and initialize runtime\n";
    content += "        runtime_ = std::make_unique<rex::Runtime>(\".\", game_dir);\n";
    content += "        runtime_->set_app_context(&app_context());\n";
    content += "\n";
    content += "        auto status = runtime_->Setup(\n";
    content += "            static_cast<uint32_t>(PPC_CODE_BASE),\n";
    content += "            static_cast<uint32_t>(PPC_CODE_SIZE),\n";
    content += "            static_cast<uint32_t>(PPC_IMAGE_BASE),\n";
    content += "            static_cast<uint32_t>(PPC_IMAGE_SIZE),\n";
    content += "            PPCFuncMappings);\n";
    content += "        if (XFAILED(status)) {\n";
    content += "            REXLOG_ERROR(\"Runtime setup failed: {:08X}\", status);\n";
    content += "            return false;\n";
    content += "        }\n";
    content += "\n";
    content += "        // Load XEX image\n";
    content += "        status = runtime_->LoadXexImage(\"game:\\\\default.xex\");\n";
    content += "        if (XFAILED(status)) {\n";
    content += "            REXLOG_ERROR(\"Failed to load XEX: {:08X}\", status);\n";
    content += "            return false;\n";
    content += "        }\n";
    content += "\n";
    content += "        // Create window\n";
    content += "        window_ = rex::ui::Window::Create(app_context(), \"" + names.snake_case + "\", 1280, 720);\n";
    content += "        if (!window_) {\n";
    content += "            REXLOG_ERROR(\"Failed to create window\");\n";
    content += "            return false;\n";
    content += "        }\n";
    content += "\n";
    content += "        // Connect graphics presenter\n";
    content += "        auto* graphics_system = runtime_->graphics_system();\n";
    content += "        if (graphics_system && graphics_system->presenter()) {\n";
    content += "            window_->SetPresenter(graphics_system->presenter());\n";
    content += "        }\n";
    content += "\n";
    content += "        window_->AddListener(this);\n";
    content += "        window_->Open();\n";
    content += "\n";
    content += "        // Launch module in background\n";
    content += "        app_context().CallInUIThreadDeferred([this]() {\n";
    content += "            auto main_thread = runtime_->LaunchModule();\n";
    content += "            if (!main_thread) {\n";
    content += "                REXLOG_ERROR(\"Failed to launch module\");\n";
    content += "                app_context().QuitFromUIThread();\n";
    content += "                return;\n";
    content += "            }\n";
    content += "\n";
    content += "            std::thread([this, main_thread = std::move(main_thread)]() mutable {\n";
    content += "                main_thread->Wait(0, 0, 0, nullptr);\n";
    content += "                REXLOG_INFO(\"Execution complete\");\n";
    content += "                app_context().CallInUIThread([this]() {\n";
    content += "                    app_context().QuitFromUIThread();\n";
    content += "                });\n";
    content += "            }).detach();\n";
    content += "        });\n";
    content += "\n";
    content += "        return true;\n";
    content += "    }\n";
    content += "\n";
    content += "    void OnClosing(rex::ui::UIEvent& e) override {\n";
    content += "        (void)e;\n";
    content += "        REXLOG_INFO(\"Window closing, shutting down...\");\n";
    content += "        app_context().QuitFromUIThread();\n";
    content += "    }\n";
    content += "\n";
    content += "    void OnDestroy() override {\n";
    content += "        if (window_) {\n";
    content += "            window_->RemoveListener(this);\n";
    content += "        }\n";
    content += "        window_.reset();\n";
    content += "        runtime_.reset();\n";
    content += "    }\n";
    content += "\n";
    content += "private:\n";
    content += "    std::unique_ptr<rex::Runtime> runtime_;\n";
    content += "    std::unique_ptr<rex::ui::Window> window_;\n";
    content += "};\n";
    content += "\n";
    content += "XE_DEFINE_WINDOWED_APP(" + names.snake_case + ", " + class_name + "::Create)\n";

    return content;
}

// Generate config.toml content
std::string generate_config_toml(const AppNameParts& names) {
    std::string content;

    content += "# " + names.snake_case + " - ReXGlue Codegen Configuration\n";
    content += "# Generated by: rexglue init\n";
    content += "# See README.md for full configuration reference.\n";
    content += "\n";
    content += "project_name = \"" + names.snake_case + "\"\n";
    content += "file_path = \"assets/default.xex\"\n";
    content += "out_directory_path = \"generated\"\n";

    return content;
}

// Generate CMakePresets.json content (no vcpkg toolchain - SDK bundles all dependencies)
std::string generate_cmake_presets() {
    std::string content;

    content += "{\n";
    content += "    \"version\": 6,\n";
    content += "    \"cmakeMinimumRequired\": { \"major\": 3, \"minor\": 25, \"patch\": 0 },\n";
    content += "    \"configurePresets\": [\n";
    content += "        {\n";
    content += "            \"name\": \"windows-base\",\n";
    content += "            \"hidden\": true,\n";
    content += "            \"generator\": \"Ninja\",\n";
    content += "            \"binaryDir\": \"${sourceDir}/out/build/${presetName}\",\n";
    content += "            \"cacheVariables\": {\n";
    content += "                \"CMAKE_C_COMPILER\": \"clang\",\n";
    content += "                \"CMAKE_CXX_COMPILER\": \"clang++\"\n";
    content += "            },\n";
    content += "            \"condition\": {\n";
    content += "                \"type\": \"equals\",\n";
    content += "                \"lhs\": \"${hostSystemName}\",\n";
    content += "                \"rhs\": \"Windows\"\n";
    content += "            }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"linux-base\",\n";
    content += "            \"hidden\": true,\n";
    content += "            \"generator\": \"Ninja\",\n";
    content += "            \"binaryDir\": \"${sourceDir}/out/build/${presetName}\",\n";
    content += "            \"cacheVariables\": {\n";
    content += "                \"CMAKE_C_COMPILER\": \"clang-20\",\n";
    content += "                \"CMAKE_CXX_COMPILER\": \"clang++-20\"\n";
    content += "            },\n";
    content += "            \"condition\": {\n";
    content += "                \"type\": \"equals\",\n";
    content += "                \"lhs\": \"${hostSystemName}\",\n";
    content += "                \"rhs\": \"Linux\"\n";
    content += "            }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"win-amd64-debug\",\n";
    content += "            \"displayName\": \"Windows AMD64 Debug\",\n";
    content += "            \"inherits\": \"windows-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Debug\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"win-amd64-release\",\n";
    content += "            \"displayName\": \"Windows AMD64 Release\",\n";
    content += "            \"inherits\": \"windows-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Release\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"linux-amd64-debug\",\n";
    content += "            \"displayName\": \"Linux AMD64 Debug\",\n";
    content += "            \"inherits\": \"linux-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Debug\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"linux-amd64-release\",\n";
    content += "            \"displayName\": \"Linux AMD64 Release\",\n";
    content += "            \"inherits\": \"linux-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Release\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"win-amd64-relwithdebinfo\",\n";
    content += "            \"displayName\": \"Windows AMD64 RelWithDebInfo\",\n";
    content += "            \"inherits\": \"windows-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"RelWithDebInfo\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"linux-amd64-relwithdebinfo\",\n";
    content += "            \"displayName\": \"Linux AMD64 RelWithDebInfo\",\n";
    content += "            \"inherits\": \"linux-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"RelWithDebInfo\" }\n";
    content += "        }\n";
    content += "    ],\n";
    content += "    \"buildPresets\": [\n";
    content += "        { \"name\": \"win-amd64-debug\", \"configurePreset\": \"win-amd64-debug\" },\n";
    content += "        { \"name\": \"win-amd64-release\", \"configurePreset\": \"win-amd64-release\" },\n";
    content += "        { \"name\": \"win-amd64-relwithdebinfo\", \"configurePreset\": \"win-amd64-relwithdebinfo\" },\n";
    content += "        { \"name\": \"linux-amd64-debug\", \"configurePreset\": \"linux-amd64-debug\" },\n";
    content += "        { \"name\": \"linux-amd64-release\", \"configurePreset\": \"linux-amd64-release\" },\n";
    content += "        { \"name\": \"linux-amd64-relwithdebinfo\", \"configurePreset\": \"linux-amd64-relwithdebinfo\" }\n";
    content += "    ]\n";
    content += "}\n";

    return content;
}

// Write a file with given content
bool write_file(const fs::path& path, const std::string& content) {
    std::ofstream file(path);
    if (!file) {
        REXLOG_ERROR("Failed to create file: {}", path.string());
        return false;
    }
    file << content;
    return true;
}
} // anonymous namespace

Result<void> InitProject(const InitOptions& opts, const CliContext& ctx) {
    (void)ctx;  // Currently unused

    // Validate required options
    if (opts.app_name.empty()) {
        return Err<void>(ErrorCategory::Config, "--app_name is required");
    }
    if (opts.app_root.empty()) {
        return Err<void>(ErrorCategory::Config, "--app_root is required");
    }

    // Validate and parse app name
    std::string validation_error;
    if (!validate_app_name(opts.app_name, validation_error)) {
        return Err<void>(ErrorCategory::Config, validation_error);
    }
    auto names = parse_app_name(opts.app_name);

    fs::path root = fs::absolute(opts.app_root);

    REXLOG_INFO("Initializing project '{}' at: {}", names.snake_case, root.string());
    REXLOG_INFO("Mode: {}", opts.sdk_example ? "SDK example" : "standalone");

    // Check if directory exists and has contents
    if (fs::exists(root)) {
        if (!fs::is_directory(root)) {
            return Err<void>(ErrorCategory::IO, "Path exists but is not a directory: " + root.string());
        }

        bool has_contents = false;
        for (const auto& entry : fs::directory_iterator(root)) {
            (void)entry;
            has_contents = true;
            break;
        }

        if (has_contents && !opts.force) {
            return Err<void>(ErrorCategory::IO, "Directory is not empty. Use --force to overwrite: " + root.string());
        }
    }

    // Create directory structure
    REXLOG_INFO("Creating directory structure...");

    std::error_code ec;
    fs::create_directories(root, ec);
    if (ec) {
        return Err<void>(ErrorCategory::IO, "Failed to create root directory: " + ec.message());
    }

    fs::create_directories(root / "src", ec);
    if (ec) {
        return Err<void>(ErrorCategory::IO, "Failed to create src directory: " + ec.message());
    }

    fs::create_directories(root / "generated", ec);
    if (ec) {
        return Err<void>(ErrorCategory::IO, "Failed to create generated directory: " + ec.message());
    }

    // Generate files
    REXLOG_INFO("Generating project files...");

    if (!write_file(root / "CMakeLists.txt", generate_cmakelists(names))) {
        return Err<void>(ErrorCategory::IO, "Failed to write CMakeLists.txt");
    }
    REXLOG_DEBUG("  Created CMakeLists.txt");

    if (!write_file(root / "src" / "main.cpp", generate_main_cpp(names))) {
        return Err<void>(ErrorCategory::IO, "Failed to write main.cpp");
    }
    REXLOG_DEBUG("  Created src/main.cpp");

    std::string config_filename = names.snake_case + "_config.toml";
    if (!write_file(root / config_filename, generate_config_toml(names))) {
        return Err<void>(ErrorCategory::IO, "Failed to write config.toml");
    }
    REXLOG_DEBUG("  Created {}", config_filename);

    if (!write_file(root / "CMakePresets.json", generate_cmake_presets())) {
        return Err<void>(ErrorCategory::IO, "Failed to write CMakePresets.json");
    }
    REXLOG_DEBUG("  Created CMakePresets.json");

    // Print success message with next steps
    REXLOG_INFO("Project '{}' initialized in '{}' successfully!", names.snake_case, opts.app_root);

    return Ok();
}

} // namespace rexglue::cli
