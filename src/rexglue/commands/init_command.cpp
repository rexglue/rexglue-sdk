/**
 * @file        rexglue/commands/init_command.cpp
 * @brief       Project initialization command implementation
 *
 * @copyright   Copyright (c) 2026 Tom Clay <tomc@tctechstuff.com>
 *              All rights reserved.
 *
 * @license     BSD 3-Clause License
 *              See LICENSE file in the project root for full license text.
 */

#include "init_command.h"
#include <rex/logging.h>
#include <rex/result.h>

#include <filesystem>
#include <fstream>
#include <algorithm>
#include <cctype>

namespace fs = std::filesystem;

namespace rexglue::cli {

using rex::Error;
using rex::ErrorCategory;
using rex::Err;
using rex::Ok;

// TODO(tomc): cleanup this shtsuff. we should have templates for file generation. idk theres prob a lib for that
namespace {

// Convert app_name to uppercase for CMake variables
std::string to_upper(const std::string& s) {
    std::string result = s;
    std::transform(result.begin(), result.end(), result.begin(),
                   [](unsigned char c) { return std::toupper(c); });
    return result;
}

// Generate CMakeLists.txt content
std::string generate_cmakelists(const InitOptions& opts) {
    std::string app_upper = to_upper(opts.app_name);
    std::string content;

    content += "# " + opts.app_name + " - ReXGlue Recompiled Project\n";
    content += "# Generated by: rexglue init\n";
    content += "\n";
    content += "cmake_minimum_required(VERSION 3.25)\n";
    content += "project(" + opts.app_name + " LANGUAGES CXX)\n";
    content += "\n";
    content += "set(CMAKE_CXX_STANDARD 23)\n";
    content += "set(CMAKE_CXX_STANDARD_REQUIRED ON)\n";
    content += "\n";
    content += "# Find ReXGlue SDK\n";
    content += "# REXSDK env var takes precedence, otherwise search system paths\n";
    content += "if(DEFINED ENV{REXSDK})\n";
    content += "    list(PREPEND CMAKE_PREFIX_PATH $ENV{REXSDK})\n";
    content += "endif()\n";
    content += "find_package(rexglue REQUIRED)\n";
    content += "if(NOT rexglue_FOUND)\n";
    content += "    message(FATAL_ERROR \"ReXGlue SDK was not found in environment variables or from find_package.\")\n";
    content += "endif()\n";
    content += "\n";
    content += "# User source files\n";
    content += "set(" + app_upper + "_SOURCES\n";
    content += "    src/main.cpp\n";
    content += ")\n";
    content += "\n";
    content += "# Platform-specific entry point (provides main/wWinMain)\n";
    content += "if(WIN32)\n";
    content += "    list(APPEND " + app_upper + "_SOURCES ${REXGLUE_SHARE_DIR}/windowed_app_main_win.cpp)\n";
    content += "else()\n";
    content += "    list(APPEND " + app_upper + "_SOURCES ${REXGLUE_SHARE_DIR}/windowed_app_main_posix.cpp)\n";
    content += "endif()\n";
    content += "\n";
    content += "# Include generated code if codegen has been run\n";
    content += "if(EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/generated/sources.cmake\")\n";
    content += "    include(generated/sources.cmake)\n";
    content += "    list(APPEND " + app_upper + "_SOURCES ${GENERATED_SOURCES})\n";
    content += "endif()\n";
    content += "\n";
    content += "if(WIN32)\n";
    content += "    add_executable(" + opts.app_name + " WIN32 ${" + app_upper + "_SOURCES})\n";
    content += "else()\n";
    content += "    add_executable(" + opts.app_name + " ${" + app_upper + "_SOURCES})\n";
    content += "endif()\n";
    content += "\n";
    content += "target_include_directories(" + opts.app_name + " PRIVATE\n";
    content += "    ${CMAKE_CURRENT_SOURCE_DIR}\n";
    content += "    ${CMAKE_CURRENT_SOURCE_DIR}/generated\n";
    content += ")\n";
    content += "\n";
    content += "target_link_libraries(" + opts.app_name + " PRIVATE\n";
    content += "    rex::core\n";
    content += "    rex::runtime\n";
    content += "    rex::kernel\n";
    content += "    rex::graphics\n";
    content += "    rex::ui\n";
    content += ")\n";
    content += "\n";
    content += "# Platform-specific settings\n";
    content += "if(UNIX AND NOT APPLE)\n";
    content += "    # GTK3 for entry point (windowed_app_main_posix.cpp)\n";
    content += "    find_package(PkgConfig REQUIRED)\n";
    content += "    pkg_check_modules(GTK3 REQUIRED gtk+-3.0)\n";
    content += "    target_include_directories(" + opts.app_name + " PRIVATE ${GTK3_INCLUDE_DIRS})\n";
    content += "    target_link_libraries(" + opts.app_name + " PRIVATE ${GTK3_LIBRARIES})\n";
    content += "\n";
    content += "    # Whole-archive linking for kernel hooks\n";
    content += "    target_link_options(" + opts.app_name + " PRIVATE\n";
    content += "        -Wl,--whole-archive\n";
    content += "        $<TARGET_FILE:rex::kernel>\n";
    content += "        -Wl,--no-whole-archive\n";
    content += "    )\n";
    content += "    # Large executable support\n";
    content += "    target_link_options(" + opts.app_name + " PRIVATE -Wl,--no-relax)\n";
    content += "    target_compile_options(" + opts.app_name + " PRIVATE -mcmodel=large)\n";
    content += "endif()\n";
    content += "\n";
    content += "if(NOT MSVC)\n";
    content += "    target_compile_options(" + opts.app_name + " PRIVATE -msse4.1)\n";
    content += "endif()\n";
    content += "\n";
    content += "# Codegen target - run 'cmake --build . --target " + opts.app_name + "_codegen'\n";
    content += "add_custom_target(" + opts.app_name + "_codegen\n";
    content += "    COMMAND $<TARGET_FILE:rex::rexglue> codegen ${CMAKE_CURRENT_SOURCE_DIR}/" + opts.app_name + "_config.toml\n";
    content += "    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}\n";
    content += "    COMMENT \"Generating recompiled code for " + opts.app_name + "\"\n";
    content += "    VERBATIM\n";
    content += ")\n";

    return content;
}

// Generate main.cpp content
std::string generate_main_cpp(const InitOptions& opts) {
    std::string content;

    content += "// " + opts.app_name + " - ReXGlue Recompiled Project\n";
    content += "// Generated by: rexglue init\n";
    content += "\n";
    content += "#include \"generated/" + opts.app_name + "_config.h\"\n";
    content += "#include \"generated/" + opts.app_name + "_init.h\"\n";
    content += "\n";
    content += "#include <rex/filesystem.h>\n";
    content += "#include <rex/runtime.h>\n";
    content += "#include <rex/logging.h>\n";
    content += "#include <rex/kernel/xthread.h>\n";
    content += "#include <rex/graphics/graphics_system.h>\n";
    content += "#include <rex/ui/window.h>\n";
    content += "#include <rex/ui/window_listener.h>\n";
    content += "#include <rex/ui/windowed_app.h>\n";
    content += "\n";
    content += "#include <filesystem>\n";
    content += "#include <thread>\n";
    content += "\n";
    content += "class " + opts.app_name + "App : public rex::ui::WindowedApp, public rex::ui::WindowListener {\n";
    content += "public:\n";
    content += "    static std::unique_ptr<rex::ui::WindowedApp> Create(rex::ui::WindowedAppContext& ctx) {\n";
    content += "        return std::make_unique<" + opts.app_name + "App>(ctx);\n";
    content += "    }\n";
    content += "\n";
    content += "    " + opts.app_name + "App(rex::ui::WindowedAppContext& ctx)\n";
    content += "        : WindowedApp(ctx, \"" + opts.app_name + "\", \"[game_directory]\") {\n";
    content += "        AddPositionalOption(\"game_directory\");\n";
    content += "    }\n";
    content += "\n";
    content += "    bool OnInitialize() override {\n";
    content += "        auto exe_dir = rex::filesystem::GetExecutableFolder();\n";
    content += "\n";
    content += "        // Game directory: arg or default to exe_dir/assets\n";
    content += "        std::filesystem::path game_dir;\n";
    content += "        if (auto arg = GetArgument(\"game_directory\")) {\n";
    content += "            game_dir = *arg;\n";
    content += "        } else {\n";
    content += "            game_dir = exe_dir / \"assets\";\n";
    content += "        }\n";
    content += "\n";
    content += "        // Initialize logging\n";
    content += "        auto log_file = exe_dir / \"" + opts.app_name + ".log\";\n";
    content += "        rex::InitLogging(log_file.string().c_str(), spdlog::level::debug);\n";
    content += "        REXLOG_INFO(\"" + opts.app_name + " starting\");\n";
    content += "        REXLOG_INFO(\"  Game directory: {}\", game_dir.string());\n";
    content += "\n";
    content += "        // Create and initialize runtime\n";
    content += "        runtime_ = std::make_unique<rex::Runtime>(\".\", game_dir);\n";
    content += "        runtime_->set_app_context(&app_context());\n";
    content += "\n";
    content += "        auto status = runtime_->Setup(\n";
    content += "            static_cast<uint32_t>(PPC_CODE_BASE),\n";
    content += "            static_cast<uint32_t>(PPC_CODE_SIZE),\n";
    content += "            static_cast<uint32_t>(PPC_IMAGE_BASE),\n";
    content += "            static_cast<uint32_t>(PPC_IMAGE_SIZE),\n";
    content += "            PPCFuncMappings);\n";
    content += "        if (XFAILED(status)) {\n";
    content += "            REXLOG_ERROR(\"Runtime setup failed: {:08X}\", status);\n";
    content += "            return false;\n";
    content += "        }\n";
    content += "\n";
    content += "        // Load XEX image\n";
    content += "        status = runtime_->LoadXexImage(\"game:\\\\default.xex\");\n";
    content += "        if (XFAILED(status)) {\n";
    content += "            REXLOG_ERROR(\"Failed to load XEX: {:08X}\", status);\n";
    content += "            return false;\n";
    content += "        }\n";
    content += "\n";
    content += "        // Create window\n";
    content += "        window_ = rex::ui::Window::Create(app_context(), \"" + opts.app_name + "\", 1280, 720);\n";
    content += "        if (!window_) {\n";
    content += "            REXLOG_ERROR(\"Failed to create window\");\n";
    content += "            return false;\n";
    content += "        }\n";
    content += "\n";
    content += "        // Connect graphics presenter\n";
    content += "        auto* graphics_system = runtime_->graphics_system();\n";
    content += "        if (graphics_system && graphics_system->presenter()) {\n";
    content += "            window_->SetPresenter(graphics_system->presenter());\n";
    content += "        }\n";
    content += "\n";
    content += "        window_->AddListener(this);\n";
    content += "        window_->Open();\n";
    content += "\n";
    content += "        // Launch module in background\n";
    content += "        app_context().CallInUIThreadDeferred([this]() {\n";
    content += "            auto main_thread = runtime_->LaunchModule();\n";
    content += "            if (!main_thread) {\n";
    content += "                REXLOG_ERROR(\"Failed to launch module\");\n";
    content += "                app_context().QuitFromUIThread();\n";
    content += "                return;\n";
    content += "            }\n";
    content += "\n";
    content += "            std::thread([this, main_thread = std::move(main_thread)]() mutable {\n";
    content += "                main_thread->Wait(0, 0, 0, nullptr);\n";
    content += "                REXLOG_INFO(\"Execution complete\");\n";
    content += "                app_context().CallInUIThread([this]() {\n";
    content += "                    app_context().QuitFromUIThread();\n";
    content += "                });\n";
    content += "            }).detach();\n";
    content += "        });\n";
    content += "\n";
    content += "        return true;\n";
    content += "    }\n";
    content += "\n";
    content += "    void OnClosing(rex::ui::UIEvent& e) override {\n";
    content += "        (void)e;\n";
    content += "        REXLOG_INFO(\"Window closing, shutting down...\");\n";
    content += "        app_context().QuitFromUIThread();\n";
    content += "    }\n";
    content += "\n";
    content += "    void OnDestroy() override {\n";
    content += "        if (window_) {\n";
    content += "            window_->RemoveListener(this);\n";
    content += "        }\n";
    content += "        window_.reset();\n";
    content += "        runtime_.reset();\n";
    content += "    }\n";
    content += "\n";
    content += "private:\n";
    content += "    std::unique_ptr<rex::Runtime> runtime_;\n";
    content += "    std::unique_ptr<rex::ui::Window> window_;\n";
    content += "};\n";
    content += "\n";
    content += "XE_DEFINE_WINDOWED_APP(" + opts.app_name + ", " + opts.app_name + "App::Create)\n";

    return content;
}

// Generate config.toml content
std::string generate_config_toml(const InitOptions& opts) {
    std::string content;

    content += "# " + opts.app_name + " - ReXGlue Codegen Configuration\n";
    content += "# Generated by: rexglue init\n";
    content += "\n";
    content += "# Required settings\n";
    content += "project_name = \"" + opts.app_name + "\"\n";
    content += "file_path = \"assets/default.xex\"\n";
    content += "out_directory_path = \"generated\"\n";
    content += "\n";
    content += "# Patch file paths (not yet implemented)\n";
    content += "# patch_file_path = \"assets/patch.xexp\"\n";
    content += "# patched_file_path = \"assets/patched.xex\"\n";
    content += "\n";
    content += "# --- Code Generation Options ---\n";
    content += "\n";
    content += "# Skip link register saves/restores (use for leaf functions)\n";
    content += "# skip_lr = false\n";
    content += "\n";
    content += "# Treat CTR as a local variable instead of global state\n";
    content += "# ctr_as_local = false\n";
    content += "\n";
    content += "# Treat XER as a local variable instead of global state\n";
    content += "# xer_as_local = false\n";
    content += "\n";
    content += "# Treat reserved registers as local variables\n";
    content += "# reserved_as_local = false\n";
    content += "\n";
    content += "# Skip MSR instructions\n";
    content += "# skip_msr = false\n";
    content += "\n";
    content += "# Treat CR registers as local variables\n";
    content += "# cr_as_local = false\n";
    content += "\n";
    content += "# Treat non-argument registers (r11-r12) as local variables\n";
    content += "# non_argument_as_local = false\n";
    content += "\n";
    content += "# Treat non-volatile registers (r14-r31) as local variables\n";
    content += "# non_volatile_as_local = false\n";
    content += "\n";
    content += "# Generate exception handler stubs\n";
    content += "# generate_exception_handlers = false\n";
    content += "\n";
    content += "# --- Analysis Tuning ---\n";
    content += "\n";
    content += "[analysis]\n";
    content += "# Maximum bytes to extend a jump target search\n";
    content += "# max_jump_extension = 65536\n";
    content += "\n";
    content += "# Minimum consecutive null bytes to mark as data region\n";
    content += "# data_region_threshold = 16\n";
    content += "\n";
    content += "# Threshold for \"large function\" warnings (bytes)\n";
    content += "# large_function_threshold = 1048576\n";
    content += "\n";
    content += "# Additional exception handler function addresses (auto-detected for __C_specific_handler)\n";
    content += "# exception_handler_funcs = [0x82000000]\n";
    content += "\n";
    content += "# --- Special Addresses ---\n";
    content += "\n";
    content += "# setjmp_address = 0x00000000\n";
    content += "# longjmp_address = 0x00000000\n";
    content += "\n";
    content += "# --- Manual Overrides ---\n";
    content += "\n";
    content += "[functions]\n";
    content += "# Define function boundaries, sizes, or custom names\n";
    content += "# 0x82000000 = { name = \"MyFunction\" }\n";
    content += "# 0x82000100 = { size = 64 }\n";
    content += "# 0x82000200 = { end = 0x82000280 }\n";
    content += "# 0x82000300 = { parent = 0x82000000, size = 32 }  # chunk of MyFunction\n";
    content += "\n";
    content += "# [[switch_tables]]\n";
    content += "# address = 0x82000000\n";
    content += "# register = 11\n";
    content += "# labels = [0x82000100, 0x82000200, 0x82000300]\n";
    content += "\n";
    content += "# [[midasm_hook]]\n";
    content += "# address = 0x82000000\n";
    content += "# name = \"MyHook\"\n";
    content += "# registers = [\"r3\", \"r4\"]\n";
    content += "\n";
    content += "# [[invalid_instructions]]\n";
    content += "# data = 0x82000000\n";
    content += "# size = 8\n";
    content += "\n";
    content += "# Known indirect calls (vtable dispatch, function pointers)\n";
    content += "# indirect_calls = [0x82000000]\n";

    return content;
}

// Generate CMakePresets.json content (no vcpkg toolchain - SDK bundles all dependencies)
std::string generate_cmake_presets() {
    std::string content;

    content += "{\n";
    content += "    \"version\": 6,\n";
    content += "    \"cmakeMinimumRequired\": { \"major\": 3, \"minor\": 25, \"patch\": 0 },\n";
    content += "    \"configurePresets\": [\n";
    content += "        {\n";
    content += "            \"name\": \"windows-base\",\n";
    content += "            \"hidden\": true,\n";
    content += "            \"generator\": \"Ninja\",\n";
    content += "            \"binaryDir\": \"${sourceDir}/out/build/${presetName}\",\n";
    content += "            \"cacheVariables\": {\n";
    content += "                \"CMAKE_C_COMPILER\": \"clang\",\n";
    content += "                \"CMAKE_CXX_COMPILER\": \"clang++\"\n";
    content += "            },\n";
    content += "            \"condition\": {\n";
    content += "                \"type\": \"equals\",\n";
    content += "                \"lhs\": \"${hostSystemName}\",\n";
    content += "                \"rhs\": \"Windows\"\n";
    content += "            }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"linux-base\",\n";
    content += "            \"hidden\": true,\n";
    content += "            \"generator\": \"Ninja\",\n";
    content += "            \"binaryDir\": \"${sourceDir}/out/build/${presetName}\",\n";
    content += "            \"cacheVariables\": {\n";
    content += "                \"CMAKE_C_COMPILER\": \"clang-20\",\n";
    content += "                \"CMAKE_CXX_COMPILER\": \"clang++-20\"\n";
    content += "            },\n";
    content += "            \"condition\": {\n";
    content += "                \"type\": \"equals\",\n";
    content += "                \"lhs\": \"${hostSystemName}\",\n";
    content += "                \"rhs\": \"Linux\"\n";
    content += "            }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"win-amd64-debug\",\n";
    content += "            \"displayName\": \"Windows AMD64 Debug\",\n";
    content += "            \"inherits\": \"windows-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Debug\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"win-amd64-release\",\n";
    content += "            \"displayName\": \"Windows AMD64 Release\",\n";
    content += "            \"inherits\": \"windows-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Release\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"linux-amd64-debug\",\n";
    content += "            \"displayName\": \"Linux AMD64 Debug\",\n";
    content += "            \"inherits\": \"linux-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Debug\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"linux-amd64-release\",\n";
    content += "            \"displayName\": \"Linux AMD64 Release\",\n";
    content += "            \"inherits\": \"linux-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"Release\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"win-amd64-relwithdebinfo\",\n";
    content += "            \"displayName\": \"Windows AMD64 RelWithDebInfo\",\n";
    content += "            \"inherits\": \"windows-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"RelWithDebInfo\" }\n";
    content += "        },\n";
    content += "        {\n";
    content += "            \"name\": \"linux-amd64-relwithdebinfo\",\n";
    content += "            \"displayName\": \"Linux AMD64 RelWithDebInfo\",\n";
    content += "            \"inherits\": \"linux-base\",\n";
    content += "            \"cacheVariables\": { \"CMAKE_BUILD_TYPE\": \"RelWithDebInfo\" }\n";
    content += "        }\n";
    content += "    ],\n";
    content += "    \"buildPresets\": [\n";
    content += "        { \"name\": \"win-amd64-debug\", \"configurePreset\": \"win-amd64-debug\" },\n";
    content += "        { \"name\": \"win-amd64-release\", \"configurePreset\": \"win-amd64-release\" },\n";
    content += "        { \"name\": \"win-amd64-relwithdebinfo\", \"configurePreset\": \"win-amd64-relwithdebinfo\" },\n";
    content += "        { \"name\": \"linux-amd64-debug\", \"configurePreset\": \"linux-amd64-debug\" },\n";
    content += "        { \"name\": \"linux-amd64-release\", \"configurePreset\": \"linux-amd64-release\" },\n";
    content += "        { \"name\": \"linux-amd64-relwithdebinfo\", \"configurePreset\": \"linux-amd64-relwithdebinfo\" }\n";
    content += "    ]\n";
    content += "}\n";

    return content;
}

// Write a file with given content
bool write_file(const fs::path& path, const std::string& content) {
    std::ofstream file(path);
    if (!file) {
        REXLOG_ERROR("Failed to create file: {}", path.string());
        return false;
    }
    file << content;
    return true;
}
} // anonymous namespace

Result<void> InitProject(const InitOptions& opts, const CliContext& ctx) {
    (void)ctx;  // Currently unused

    // Validate required options
    if (opts.app_name.empty()) {
        return Err<void>(ErrorCategory::Config, "--app_name is required");
    }
    if (opts.app_root.empty()) {
        return Err<void>(ErrorCategory::Config, "--app_root is required");
    }

    fs::path root = fs::absolute(opts.app_root);

    REXLOG_INFO("Initializing project '{}' at: {}", opts.app_name, root.string());
    REXLOG_INFO("Mode: {}", opts.sdk_example ? "SDK example" : "standalone");

    // Check if directory exists and has contents
    if (fs::exists(root)) {
        if (!fs::is_directory(root)) {
            return Err<void>(ErrorCategory::IO, "Path exists but is not a directory: " + root.string());
        }

        bool has_contents = false;
        for (const auto& entry : fs::directory_iterator(root)) {
            (void)entry;
            has_contents = true;
            break;
        }

        if (has_contents && !opts.force) {
            return Err<void>(ErrorCategory::IO, "Directory is not empty. Use --force to overwrite: " + root.string());
        }
    }

    // Create directory structure
    REXLOG_INFO("Creating directory structure...");

    std::error_code ec;
    fs::create_directories(root, ec);
    if (ec) {
        return Err<void>(ErrorCategory::IO, "Failed to create root directory: " + ec.message());
    }

    fs::create_directories(root / "src", ec);
    if (ec) {
        return Err<void>(ErrorCategory::IO, "Failed to create src directory: " + ec.message());
    }

    fs::create_directories(root / "generated", ec);
    if (ec) {
        return Err<void>(ErrorCategory::IO, "Failed to create generated directory: " + ec.message());
    }

    // Generate files
    REXLOG_INFO("Generating project files...");

    if (!write_file(root / "CMakeLists.txt", generate_cmakelists(opts))) {
        return Err<void>(ErrorCategory::IO, "Failed to write CMakeLists.txt");
    }
    REXLOG_DEBUG("  Created CMakeLists.txt");

    if (!write_file(root / "src" / "main.cpp", generate_main_cpp(opts))) {
        return Err<void>(ErrorCategory::IO, "Failed to write main.cpp");
    }
    REXLOG_DEBUG("  Created src/main.cpp");

    std::string config_filename = opts.app_name + "_config.toml";
    if (!write_file(root / config_filename, generate_config_toml(opts))) {
        return Err<void>(ErrorCategory::IO, "Failed to write config.toml");
    }
    REXLOG_DEBUG("  Created {}", config_filename);

    if (!write_file(root / "CMakePresets.json", generate_cmake_presets())) {
        return Err<void>(ErrorCategory::IO, "Failed to write CMakePresets.json");
    }
    REXLOG_DEBUG("  Created CMakePresets.json");

    // Print success message with next steps
    REXLOG_INFO("Project '{}' initialized in '{}' successfully!", opts.app_name, opts.app_root);

    return Ok();
}

} // namespace rexglue::cli
